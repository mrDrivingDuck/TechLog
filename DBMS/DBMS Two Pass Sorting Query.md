# DBMS - Two Pass Sorting Query

Created by : Mr Dk.

2019 / 12 / 16 10:30

Nanjing, Jiangsu, China

---

基于排序的两趟算法

---

## 两阶段多路归并排序

Two-Phase Multiway Merge-Sort, TPMMS

有 M 个内存缓冲区用于排序

可以对非常大的关系进行排序

阶段 1:

* 不断将 R 中的元组放入 M 个缓冲区，用主存排序算法进行排序
* 这样可以得到缓冲区内有序的大量子表 - `⌈B(R)/M⌉` 个子表？

阶段 2:

* 条件 - 最多能对 `M-1` 个有序的子表进行归并
* 将 `M-1` 个子表从最小的块开始，移动到 `M-1` 个缓冲区中
* 使用一个缓冲区用于输出，对 `M-1` 个子表作归并排序
    * 如果子表的一块扫描完毕，则载入下一块
    * 如果输出缓冲区已满，则保存到外存后，重新初始化新的输出缓冲区

需要注意的几个问题：

1. 需要寻找所有子表中第一个元素的最小值 (内存操作)
2. 将最小的元素移到输出块的第一个可用位置
3. 若输出块已满，则写入磁盘，并重新初始化一个输出缓冲块
4. 如果刚被取出最小元素的缓冲块已被耗尽，则将有序子表的下一个块读入缓冲区

为了使 TPMMS 能正常工作，子表不能超过 `M-1` 个

这个条件也就决定了 `B(R) ≤ M(M-1)`

算法代价：第一趟读入 B 块 + 写回 B 块子表 + 依次读入内存归并 = 3B(R) 次 I/O

---

## 利用排序去除重复

与 TPMMS 类似，用两趟算法实现 δ (去重)

首先以 M 个缓冲区为单位将数据读入内存进行排序，得到 `⌈B(R)/M⌉` 个子表

将每个子表的第一块读入缓冲区 (子表的个数不能超过 `M-1`)

将每块中的第一个未考虑元素复制到输出缓冲区，并忽略所有相同元素

结果:

* 输出块中，对于每个元组，都只有一个实例
* 按序产生

代价: 读入内存排序 + 写回硬盘 + 读入内存归并 = 3B(R) 次 I/O

条件: `B ≤ M^2`

> 可以用同样多的缓冲块
>
> 处理比一趟算法大得多的文件
>
> 代价是更多次的磁盘 I/O，即性能

---

## 利用排序进行分组和聚集

基于 TPMMS 进行 `γ` (分组或聚集)

将 M 块元组依次读入缓冲区进行主存排序

* 排序关键字使用 __分组属性__

排好序的子表写回磁盘

为每个子表分配一个内存缓冲，并读取每个子表的第一块

* 取得所有子表中，分组属性 (排序关键字) 的最小值 - 作为下一个分组
    * 准备计算这个分组的所有聚集
    * 检查每一个排序关键字相同的元组，累计聚集
    * 如果已经扫描到缓冲区的尾部，则调入子表中的下一个缓冲区
* 当不再有相同排序关键字的元组时，输出该分组及其所有的聚集

代价和条件与上述相同

---

## 基于排序的并算法

一趟算法起作用的条件 - 至少一个关系小于可用主存

当两个关系都大于可用主存时

同样使用类似于 TPMMS 的思想:

1. 第一趟读入内存，创建 R 和 S 两个关系的排序子表
2. 为 R 和 S 的每一个子表分配一个缓冲区，并读入各子表的第一个块
3. 在所有缓冲区中选择最小的元组，复制到输出缓冲区，并忽略其它缓冲区中的相同元组
    * 当缓冲区扫描完毕时，读入子表的下一个块

代价: R 与 S 的每一个元组被读入缓冲区两次，之间写回了一次 - `3(B(R) + B(S))`

条件: 每个子表需要一个缓冲区，还需要一个缓冲区用于输出

* `⌈B(R)/M⌉ + ⌈B(S)/M⌉ ≤ M-1`，近似于 `B(R) + B(S) ≤ M^2`

---

## 基于排序的交和差算法

依旧使用了处理排序子表的方式

但在细节上有所差别

首先构造两个关系的排序子表

并将两个关系的每个排序子表的第一块读入缓冲区

* 对于集合交，扫描每个块的最小元组，如果同时出现在 R 和 S 中，就输出
* 对于包交，扫描每个块的最小元组，并统计在关系中出现的次数，输出该元组在 R 和 S 中出现的最小次数
* 对于集合差
    * 此时 R 与 S 地位平等
    * 扫描每个块中的最小元组，输出出现在一个关系但未出现在另一个关系中的元组
* 对于包差
    * 扫描每个块中的最小元组
    * 若 `t` 元组在 R 中出现 `t1` 次，在 S 中出现 `t2` 次，则 `R-S` 输出 `t` 元组 `t1-t2` 次

需要注意的地方:

* 计算某个元组出现的次数时，如果缓冲区中剩余元素都是 `t`，那么下一个缓冲区中可能还有更多的 `t`
* 这个过程可能还会在若干个缓冲区上出现，甚至还会出现在若干个子表上

代价与条件同上

---

## 基于排序的一个简单的连接算法

用于对较大的关系进行连接

已知要连接的关系为 `R(X, Y)` 和 `S(Y, Z)`，有 M 个内存缓冲区

使用 TPMMS 对 R 和 S 进行排序，排序关键字为 `Y`，归并后将结果写回磁盘

使用两个缓冲区，将 R 和 S 的最小块分别读入内存，查找连接属性的最小值

* 如果一个值在另一个关系中没有出现，则跳过
* 否则连接具有相同连接属性的元组，并输出

代价: 归并排序 `3(B(R) + B(S))` + 写回磁盘 `B(R) + B(S)` + 连接 `B(R) + B(S)`

总共为 `5(B(R) + B(S))`

在某些情况下，这个代价会比嵌套循环连接好

* 因为嵌套循环连接是一个 `O(n^2)` 的算法

条件:

* 需要满足归并排序的 `B(R) ≤ M^2` 且 `B(S) ≤ M^2`
* 具有相同连接属性的元组必须能够全部装入 M 个缓冲区中

---

## 一种更有效的基于排序的连接

如果不担心在连接属性上具有公共值的元组太多

可以将排序的第二阶段和连接合并

从而使每块可以节省 2 次 I/O (写回磁盘 + 读入内存)

首先将 Y 作为关键字对 R 和 S 进行排序，得到大小为 M 的有序子表

将每个子表的第一块调入缓冲区

* 在每个子表中找到最小的公共连接属性
* 连接两个关系中具有相同连接属性的所有元组并输出

每个子表处理完毕后，将子表的下一块调入缓冲区

代价: `3(B(R) + B(S))`

条件: 两个关系的有序子表个数不能超过 M - 即 `B(R) + B(S) ≤ M^2`

---

