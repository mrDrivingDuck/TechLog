# DBMS - One Pass Query Execution

Created by : Mr Dk.

2019 / 12 / 14 11:47

Nanjing, Jiangsu, China

---

## 查询编译过程

* 分析，建立 __分析树__
* 查询重写，分析树被转化为 __初始查询计划__ ，并再被转化为预期所需时间较小的等价查询计划
* 物理计划生成，将 __逻辑查询计划__ 中的每个操作符选择实现算法和执行顺序，转换为 __物理查询计划__

查询优化的每个选择都依赖于 DBMS 的 __元数据__ ，比如：

* 每个关系的大小
* 统计数据
* 索引
* 数据在磁盘上的分布

---

## 物理查询计划

由几个物理操作符组成

每个操作符的代价使用 __磁盘 I/O 数组__ 作衡量

假设：操作对象都放在磁盘上，操作结果放在内存中

* 将操作结果放回磁盘的代价仅依赖于结果的大小，不依赖于结果是如何被计算的
* 很多应用中，结果不需要被放到磁盘上，而是打印

衡量查询代价的参数：

* 可以获得的内存缓冲区数目 `M`
* 每个关系中，所有元组所需要的块数目 `B`
* 关系中元组的数目 `T`
* 关系在一个列中不同值的数目 `V`

---

## 一趟算法 (one-pass)

仅从磁盘读取一次数据，要求至少一个操作对象能完全装入内存

### 单个元组操作

* `σ` 选择
* `π` 投影

只需一次读取 R 关系中的一块到缓冲区

对每个元组进行操作

然后将选择或投影的元组移到输出缓冲区

条件：输入缓冲区 `M ≥ 1`

代价：

* 如果 R 是聚集的，代价为 B (块的个数)
* 如果 R 不是聚集的，代价为 T (元组的个数)

### 整个关系的一元操作

#### `δ` 消除重复操作

由于要去重，所以对于每一个元素需要判定：

* 第一次见到这个元组，则复制到输出
* 从前见过这个元组，则跳过

用 `1` 个缓冲区存放 R 的一个块

用 `M-1` 个缓冲区保存目前为止见过的每个元组的副本

为了查找性能，可以在 `M-1` 块中使用具有大量桶的散列表

或某种形式的 BST

#### `γ` 分组操作

0 个或多个 __分组属性__ 及其可能的一个或多个 __聚集属性__

在主存中为 __每一个组__ 建立一个项，并一次一块地扫描 R 中的元组

* 对 `MIN(a)` 或 `MAX(a)`，记录每个组在属性 a 上的最小值或最大值
* 对 `COUNT` 来说，记录每个组中的元组个数
* 对 `SUM(a)` 来说，记录每个组中 a 属性的累加
* 对 `AVG(a)` 来说，记录组内元素个数以及 a 属性的累加；所有元组扫描完毕后，计算平均值

需要使用内存数据结构，便于快速查找各个分组的项，查找关键字是分组属性

### 二元操作

二元操作 - 需要将 R 和 S 中较小的关系读入内存，并建立合适的数据结构

近似需求：`min(B(R), B(S)) ≤ M`

* 1 个缓冲区用于读取较大关系的块
* M-1 个缓冲区用于容纳较小的关系，及其数据结构

接下来假定关系 R 是较大的那一个

#### 集合并

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

S 的全部元组复制到输出中

一次一块将 R 读入缓冲区，对于 R 的每个元组 t

* 如果 t 在 S 中，则跳过
* 如果 t 不在 S 中，则将 t 复制到输出

#### 集合交

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

* 如果 t 也在 S 中，则将 t 复制到输出
* 如果 t 不在 S 中，则跳过

#### 集合差

差运算不可交换，因为对于顺序要做区分

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

* R - S
    * 如果 t 在 S 中，则跳过
    * 如果 t 不在 S 中，则将 t 复制到输出
* S - R
    * 如果 t 在 S 中，从主存中删除 S 中的 t
    * 如果 t 不在 S 中，不作任何处理
    * 将 S 中的剩余元组复制到输出

#### 包交

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

另外，还需要把每个不同的元组和一个计数器联系起来

* 初始值为该元组在 S 中出现的次数
* S 中的多个副本不分别存储

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

* 如果 t 也在 S 中
    * 若 t 对应的计数器为正，则输出 t，并计数 - 1
    * 如果计数器已经为 0，那么不输出 t
    * 从而，输出 t 的数量与 S 中一样多
* 如果 t 不在 S 中，则忽略

#### 包差

差运算不可交换，因为对于顺序要做区分

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

另外，还需要把每个不同的元组和一个计数器联系起来

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

* R - S
    * 如果 t 在 S 中
        * 若 t 的计数器为正，则将计数器 - 1
        * 若 t 的计数器为 0，则将 t 复制到输出
    * 如果 t 不在 S 中，则将 t 复制到输出
* S - R
    * 如果 t 在 S 中，将 t 的计数 - 1
    * 如果 t 不在 S 中，不作任何处理
    * 将 S 中的剩余计数为正的元组复制到输出，且复制次数为对应的计数器计数

#### 积

将 S 读到 `M-1` 个缓冲区中，并建立查找结构

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

将 t 与 S 的每一个元组连接，并输出

#### 自然连接

`R(X, Y)` 与 `S(Y, Z)` 的连接

读取 S 中的所有元组，构造为以 `Y` 为查找关键字的查找结构，使用 `M-1` 个缓冲区

一次一块将 R 读入缓冲区，对于 R 中的每个元组 t

将 t 与 `Y` 上所有相符合的元组连接，并输出

---

以上所有算法需要的条件：

较小的关系能够完整地装入内存缓冲区中

---

一趟半算法 - 嵌套循环连接

两个关系的元组中

* 一个关系的元组只被读取一次
* 另一个关系的元组被反复读取

嵌套循环连接可以用于 __任意大小的关系__

没有必要要求一个关系能被装入内存

原则：

1. 对操作对象的访问均以块为单位
2. 使用尽可能多的内存来存储外层循环中的关系
    * 使内存循环中的每个元组可以与尽可能多的外层循环的元组连接

依旧假设关系 S 的大小小于 R

但 `B(S) > M`，也就是任何关系都不能完整装入内存

首先将 S 的 `M-1` 个块读到内存中

并按 R 和 S 的公共属性 (连接属性) 为查找关键字创建内存查找结构

将 R 的所有元组依次读入剩下的缓冲区中，并与 S 在内存中的 `M-1` 个块进行比较

如果能连接，就连接并输出

等整个 R 扫描完毕后，将 S 的下一个 `M-1` 个块读入内存，依次类推

> 在抽象层次上，存在两层循环
>
> 一般来说，在外层循环中使用较小的关系略有优势
>
> 假设 R、S、M 分别为上述含义
>
> 若 R 为外层循环，磁盘 I/O 次数为：`R/(M-1) * (M-1 + S)`
>
> 若 S 为外层循环，磁盘 I/O 次数为：`S/(M-1) * (M-1 + R)`
>
> 显然，S 为外层循环更具优势

---

