# DBMS - Algorithm based on Index

Created by : Mr Dk.

2019 / 12 / 21 10:49

Nanjing, Jiangsu, China

---

基于索引的算法

---

## 聚簇和非聚簇索引

一个关系中的元组能够紧缩到存储这些元组的尽可能少的块中

那么这个关系就是 __聚簇__ 的

---

## 基于索引的选择

对于选择操作 `σ`

如果 R 上没有索引

* 如果是聚簇的，那么需要扫描 `B(R)`
* 如果不是聚簇的，那么需要扫描 `T(R)`

如果 R 上有索引且聚簇

* 只需要 `B(R) / V(R, a)` 次 I/O
* 实际情况代价可能更高一些
    * 索引并不完全保存在内存中
    * 即使所有元组都聚簇，由于不一定在块起始处开始存放，可能需要多读一块

如果 R 上有索引但非聚簇

* `T(R) / V(R, a)`

---

## 使用索引的连接

一种算法: 检查 R 的每一个块，考虑每一个元组

使用索引在 S 中找到所有出现该连接属性的元组并连接

* 如果 R 是聚簇的，需要读取 `B(R)` 个块得到 R 的所有元组
* 如果 R 是非聚簇的，需要 `T(R)` 次磁盘 I/O 得到 R 的所有元组

再加上连接的索引查询代价:

* 如果 S 在 Y 上有非聚簇索引，代价为 `T(S) / V(S, Y)`
* 如果索引是聚簇的，代价为 `B(S) / V(S, Y)`

不管 R 是否聚簇，访问 S 中元组的代价占主导地位

---

## 使用有序索引的连接

比如 B-tree 等

可以直接执行排序-连接，但是可以不用预先对关系进行排序

(因为索引能够提供顺序)

如果 R 和 S 上都有有序索引

则进一步变为 __zig-zag 连接__

* 在两个索引之间跳来跳去，查找共享的 Y 值

---

