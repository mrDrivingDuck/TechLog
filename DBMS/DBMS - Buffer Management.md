# DBMS - Buffer Management

Created by : Mr Dk.

2019 / 12 / 24 0:14

Nanjing, Jiangsu, China

---

## 缓冲区管理结构

缓冲区管理器需要对使用的缓冲区数加以一定限制

使其能够适应内存容量

1. (大多数 __关系型 DBMS__) 缓冲区管理器直接控制内存
    * 当超过了可以得到的空间时，需要将缓冲区中的内容搬到磁盘上
2. 缓冲区管理器在 __虚拟内存__ 中分配缓冲区，允许 OS 决定哪些缓冲区真正在内存
    * 可以分配超过内存容量的缓冲区
    * 但如果这些缓冲区都被使用，将导致 _颠簸_ ，即许多块在磁盘 swap 分区移进移出

---

## 缓冲区管理策略

关键的选择问题: 当一个新近要求的块需要缓冲区时，应该把哪一块丢出缓冲池

### LRU

丢出最长时间没有被读写的块

* 需要缓冲区管理器维护一张 LRU 表
* 维护该信息需要一些工作量

### FIFO

被同一个块占用时间最长的缓冲区被清空用于新块

* 需要较少的维护开销
* 会导致很多的错误 - 比如 B-Tree 的根结点会被经常访问，却会最终成为最旧的块

### 时钟算法 (第二次机会)

将缓冲区看作一个排好的环

一个 __指针__ 指向其中一个缓冲区

顺时针旋转指针

每个缓冲区带有一个 flag - `0/1`

* flag 为 `0` 的缓冲区被选中，写回磁盘
* 当一个块被读入缓冲区时，flag 为 `1`
* 当缓冲区中的内容被访问过后，flag 也为 `1`

寻找新的缓冲区时:

1. 顺时针旋转指针
2. 通过 flag 为 `1` 的缓冲区，就将其设置为 `0`
3. 查找到能够找到的第一个 flag 为 `0` 的缓冲区

> 一个 flag 为 `1` 的缓冲区在第二次才有可能被替换
>
> 如果中间这个缓冲区被访问了，那么机会又多了一次
>
> 这样算是 LRU 的一个近似，不过避免了一些意外情况

进一步的技巧:

* 对于一些想要一直被留在内存中的块，赋予 flag 一个大于 `1` 的值，甚至是无限大的值
* 如果想要释放时，将 flag 设置为 `0` 即可

### 系统控制

由查询优化器或其它 DBMS 部件给缓冲区管理器提供建议

---

